# frozen_string_literal: true

default_platform(:ios)

IOS_PROJECT = "ios/App/App.xcodeproj"
IOS_SCHEME = "App"
IOS_APP_IDENTIFIER = "com.yancmo.crumb"

platform :ios do
  before_all do
    # Avoid "xcodebuild -list" timeouts on some machines.
    ENV["FASTLANE_XCODE_LIST_TIMEOUT"] ||= "120"

    UI.message("Using iOS project: #{IOS_PROJECT} (scheme: #{IOS_SCHEME})")
    UI.message("App identifier: #{IOS_APP_IDENTIFIER}")
  end

  desc "Runs iOS unit/UI tests (if present)"
  lane :tests do
    scan(
      project: IOS_PROJECT,
      scheme: IOS_SCHEME,
      clean: true,
      derived_data_path: ENV["SCAN_DERIVED_DATA_PATH"]
    )
  end

  private_lane :maybe_setup_api_key do
    key_id = ENV["ASC_KEY_ID"].to_s.strip
    issuer_id = ENV["ASC_ISSUER_ID"].to_s.strip
    key_path = ENV["ASC_KEY_PATH"].to_s.strip

    if key_id.empty? || issuer_id.empty? || key_path.empty?
      UI.important("ASC_* vars not set; Fastlane will fall back to Apple ID session auth where required.")
      next
    end

    UI.message("Using App Store Connect API key auth (ASC_KEY_ID=#{key_id})")
    app_store_connect_api_key(
      key_id: key_id,
      issuer_id: issuer_id,
      key_filepath: key_path,
      duration: 1200
    )
  end

  private_lane :maybe_setup_api_key_for_deliver do
    if ENV["DELIVER_USE_API_KEY"].to_s == "1"
      maybe_setup_api_key
    else
      UI.message("DELIVER_USE_API_KEY!=1; deliver lanes will use Apple ID session auth by default.")
    end
  end

  private_lane :should_wait_for_processing? do
    ENV["WAIT_FOR_PROCESSING"].to_s == "1" || ENV["CRUMB_WAIT_FOR_PROCESSING"].to_s == "1"
  end

  desc "Creates an archive + IPA (no upload)"
  lane :archive do
    build_app(
      project: IOS_PROJECT,
      scheme: IOS_SCHEME,
      clean: true,
      export_method: "app-store",
      xcargs: "-allowProvisioningUpdates"
    )
  end

  desc "Forces a build number bump (CURRENT_PROJECT_VERSION)"
  lane :force_bump do
    # Uses agvtool under the hood when given an xcodeproj.
    increment_build_number(
      xcodeproj: IOS_PROJECT
    )
    UI.success("Bumped build number to #{get_build_number(xcodeproj: IOS_PROJECT)}")
  end

  desc "Builds + uploads to TestFlight"
  lane :beta do
    maybe_setup_api_key

    build_app(
      project: IOS_PROJECT,
      scheme: IOS_SCHEME,
      clean: true,
      export_method: "app-store",
      xcargs: "-allowProvisioningUpdates"
    )

    upload_to_testflight(
      app_identifier: IOS_APP_IDENTIFIER,
      skip_waiting_for_build_processing: !should_wait_for_processing?
    )
  end

  desc "Force bump, then build + upload"
  lane :beta_force do
    force_bump
    beta
  end

  desc "Shows latest TestFlight build number for the current marketing version"
  lane :tf_status do
    maybe_setup_api_key

    version = get_version_number(xcodeproj: IOS_PROJECT, target: IOS_SCHEME)
    build = latest_testflight_build_number(
      app_identifier: IOS_APP_IDENTIFIER,
      version: version
    )

    UI.message("Latest processed TestFlight build for #{IOS_APP_IDENTIFIER} v#{version}: #{build}")
  end

  desc "Lists all processed TestFlight builds (delegates to pilot CLI)"
  lane :tf_list_all do
    maybe_setup_api_key

    sh("bundle exec pilot builds --app_identifier '#{IOS_APP_IDENTIFIER}'")
  end

  desc "Uploads metadata/screenshots if present (no binary upload)"
  lane :upload_metadata do
    maybe_setup_api_key_for_deliver

    has_metadata = Dir.exist?("fastlane/metadata")
    has_screens = Dir.exist?("fastlane/screenshots")

    unless has_metadata || has_screens
      UI.important("No fastlane/metadata or fastlane/screenshots found; skipping deliver.")
      next
    end

    deliver(
      app_identifier: IOS_APP_IDENTIFIER,
      skip_binary_upload: true,
      force: true
    )
  end

  desc "Submits the latest build for App Store review (assumes metadata already uploaded)"
  lane :release do
    maybe_setup_api_key_for_deliver

    deliver(
      app_identifier: IOS_APP_IDENTIFIER,
      submit_for_review: true,
      force: true
    )
  end

  desc "Uploads metadata/screenshots and submits for review"
  lane :release_full do
    maybe_setup_api_key_for_deliver

    deliver(
      app_identifier: IOS_APP_IDENTIFIER,
      submit_for_review: true,
      force: true
    )
  end
end
